bundle agent manage_sysctl_conf_selective_present(settings)
# @brief Manage individual settings in /etc/sysctl.conf and reload sysctl on repair
{
  vars:
    linux::
      # Set the sysconfig file to operate on based on our settings bundle
      "sysctl_conf_file"
        string => "$($(settings).file[sysctl])";

      # Copy the sysctl settings from our settings bundle
      # Settings are expected to be defined in an array, or equivlent data
      # container for example `sysctl[net.ipv4.ip_forward] string => "0"`
      "sysctl_conf" data => mergedata("$(settings).sysctl");

  classes:
      # We want to know if we are editing the main sysctl.conf so that
      # we know if we should attempt to reload the settings if it has
      # been repaired
      "using_default_sysctl_conf_file" 
        expression => strcmp($(sysctl_conf_file), "/etc/sysctl.conf");

  files:
    linux::
      "$(sysctl_conf_file)"
        perms => mog("400", "root", "root");

      "$(sysctl_conf_file)"
        create => "true",
        edit_line => set_line_based("$(this.bundle).sysctl_conf", "=", "\s*=\s*", ".*", "\s*#\s*"),
        classes => scoped_classes_generic("bundle", "sysctl_conf_file"),
        comment =>  "sysctl settings can be very important to the performance of systems and applications";

  commands:
    linux.sysctl_conf_file_repaired::
      # Reload sysctl settings if they have been modified
      "$(paths.sysctl)"
        args => "-p $(sysctl_conf_file)",
        handle => "$(this.bundle)_sysctl_reload_after_repair",
        comment => "After $(sysctl_conf_file) has been modified, sysctl must reload it for settings to apply.",
        ifvarclass => "using_default_sysctl_conf_file";

  reports:
    DEBUG|DEBUG_manage_sysctl_conf::
      "bundle:$(this.bundle) Activated";
      "$(const.t)$(sysctl_conf_idx) = $(sysctl_conf[$(sysctl_conf_idx)])";
      "$(const.t)Repaired: '$(sysctl_conf_file)' was corrected"
        ifvarclass => "sysctl_conf_file_repaired";
}
